<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>lockc Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="**lockc** is open source software for providing MAC (Mandatory Access Control) implemented in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="containers-do-not-contain.html"><strong aria-hidden="true">2.</strong> Containers do not contain</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">4.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install/index.html"><strong aria-hidden="true">4.1.</strong> Install</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install/docker.html"><strong aria-hidden="true">4.1.1.</strong> With Docker</a></li><li class="chapter-item expanded "><a href="install/kubernetes.html"><strong aria-hidden="true">4.1.2.</strong> With Kubernetes</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="policies/index.html"><strong aria-hidden="true">5.</strong> Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="policies/file-access.html"><strong aria-hidden="true">5.1.</strong> File access</a></li><li class="chapter-item expanded "><a href="policies/mount.html"><strong aria-hidden="true">5.2.</strong> Mount</a></li><li class="chapter-item expanded "><a href="policies/syslog.html"><strong aria-hidden="true">5.3.</strong> Syslog</a></li></ol></li><li class="chapter-item expanded "><a href="tuning/index.html"><strong aria-hidden="true">6.</strong> Tuning</a></li><li class="chapter-item expanded "><a href="developers/index.html"><strong aria-hidden="true">7.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developers/repositories.html"><strong aria-hidden="true">7.1.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="developers/build/index.html"><strong aria-hidden="true">7.2.</strong> Build</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developers/build/cargo.html"><strong aria-hidden="true">7.2.1.</strong> Cargo</a></li><li class="chapter-item expanded "><a href="developers/build/container-image.html"><strong aria-hidden="true">7.2.2.</strong> Container image</a></li></ol></li><li class="chapter-item expanded "><a href="developers/vagrant/index.html"><strong aria-hidden="true">7.3.</strong> Development environment (Vagrant)</a></li></ol></li><li class="chapter-item expanded "><a href="demos/index.html"><strong aria-hidden="true">8.</strong> Demos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="demos/mount.html"><strong aria-hidden="true">8.1.</strong> Mount</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">lockc Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lockc-project/lockc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="https://lockc-project.github.io/images/logo-horizontal-lockc.png" alt="lockc" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>lockc</strong> is open source software for providing MAC (Mandatory Access Control)
type of security audit for container workloads.</p>
<p>The main reason why <strong>lockc</strong> exists is that <strong>containers do not contain</strong>.
Containers are not as secure and isolated as VMs. By default, they expose
a lot of information about host OS and provide ways to &quot;break out&quot; from the
container. <strong>lockc</strong> aims to provide more isolation to containers and make them
more secure.</p>
<p>The <a href="containers-do-not-contain.html">Containers do not contain</a> documentation
section explains why we mean by that phrase and what kind of behavior we want
to restrict with <strong>lockc</strong>.</p>
<p>The main technology behind lockc is <a href="https://ebpf.io/">eBPF</a> - to be more
precise, its ability to attach to <a href="https://www.kernel.org/doc/html/latest/bpf/bpf_lsm.html">LSM hooks</a></p>
<p>Please note that currently lockc is an experimental project, not meant for
production environments. Currently we don't publish any official binaries or
packages to use, except of a Rust crate. Currently the most convenient way
to use it is to use the source code and follow the guide.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>If you need help or want to talk with contributors, please come chat with
us on <code>#lockc</code> channel on the <a href="https://discord.gg/799cmsYB4q">Rust Cloud Native Discord server</a>.</p>
<p>You can find the source code on <a href="https://github.com/lockc-project/lockc">GitHub</a>
and issues and feature requests can be posted on the
<a href="https://github.com/lockc-project/lockc/issues">GitHub issue tracker</a>.
<strong>lockc</strong> relies on the community to fix bugs and add features: if you'd like
to contribute, please read the <a href="https://github.com/lockc-project/lockc/blob/master/CONTRIBUTING.md">CONTRIBUTING</a>
guide and consider opening <a href="https://github.com/lockc-project/lockc/pulls">pull request</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><strong>lockc's</strong> userspace part is licensed under <a href="https://github.com/lockc-project/lockc/blob/main/LICENSE">Apache License, version 2.0</a>.</p>
<p>eBPF programs inside <a href="https://github.com/lockc-project/lockc/tree/main/lockc/src/bpf">lockc/src/bpf directory</a>
are licensed under <a href="https://github.com/lockc-project/lockc/blob/main/lockc/src/bpf/LICENSE">GNU General Public License, version 2</a>.</p>
<p>Documentation is licensed under <a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License v2.0</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers-do-not-contain"><a class="header" href="#containers-do-not-contain">Containers do not contain</a></h1>
<p>Many people assume that containers:</p>
<ul>
<li>provide the same or similar isolation to virtual machines</li>
<li>protects the host system</li>
<li>sandboxes applications</li>
</ul>
<p>While all the points except the first one are partially true, some parts of the
host filesystems are still exposed by default to containers and there are ways to
gain full access.</p>
<p>This section highlights and explains problematic exploitation possibilities
that <strong>lockc</strong> aims to fix via policies.</p>
<p>Please note that as <strong>lockc</strong> is still in early development stage, it doesn't
protect against all examples provided at this time. However, covering them all
is in the roadmap.</p>
<p>The goal of <strong>lockc</strong> is to eventually prevent any of those examples to be done
by a regular user. Following some examples as root by explicitly choosing the
<em>privileged</em> policy level in lockc is going to be still allowed. However, it is
is discouraged to use the <em>priviliged</em> level for containers which are not part
of Kubernetes infra (CNI plugins, operators, network meshes etc.). We might
still consider restricting some of behaviors even for <em>privileged</em> (i.e. it's
probably hard to justify <code>chroot</code> inside containers under any ciricumstance).</p>
<h2 id="not-everything-is-namespaced"><a class="header" href="#not-everything-is-namespaced">Not everything is namespaced</a></h2>
<p>Despite the fact that containers come with their own rootfs, some parts of the
filesystem are <strong>not namespaced</strong>, which means that the content of some
directories is <strong>exactly the same as on the host OS</strong>. Examples:</p>
<ul>
<li>Kernel filesystems under <em>/sys</em></li>
<li>many sysctls under <em>/proc/sys</em></li>
</ul>
<p>For non-privileged containers, the content of those directories is read-only.
However, privileged containers can write to them. In both cases, we think that
even exposing many of those directories without write access is unnecessary
for regular containers.</p>
<p>To show some more concrete examples, access to those directories can allow to:</p>
<ul>
<li>Check and change GPU settings</li>
</ul>
<pre><code class="language-bash">❯ docker run --rm -it opensuse/tumbleweed:latest bash
f4891490a2f3:/ # cat /sys/class/drm/card0/device/power_dpm_force_performance_level
auto
f4891490a2f3:/ # exit
❯ docker run --rm --privileged -it opensuse/tumbleweed:latest bash
bad479286479:/ # echo high &gt; /sys/class/drm/card0/device/power_dpm_force_performance_level
bad479286479:/ # cat /sys/class/drm/card0/device/power_dpm_force_performance_level
high
bad479286479:/ # exit
❯ cat /sys/class/drm/card0/device/power_dpm_force_performance_level
high
</code></pre>
<ul>
<li>look at the host OS filesystem metadata</li>
</ul>
<pre><code class="language-bash">❯ docker run --rm -it opensuse/tumbleweed:latest bash
0d35122d08f9:~ # ls /sys/fs/btrfs/a8222a26-d11e-4276-9c38-9df2812cead2/
allocation  bdi  bg_reclaim_threshold  checksum  clone_alignment  devices  devinfo  exclusive_operation  features  generation  label  metadata_uuid  nodesize  qgroups  quota_override  read_policy  sectorsize
</code></pre>
<ul>
<li>use fdisk in a privileged container</li>
</ul>
<pre><code class="language-bash">❯ docker run --rm -it --privileged registry.opensuse.org/opensuse/toolbox:latest bash
8b71e0119552:/ # fdisk -l
Disk /dev/nvme0n1: 1.82 TiB, 2000398934016 bytes, 3907029168 sectors
Disk model: Samsung SSD 970 EVO Plus 2TB
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 8EEBDAB8-F965-4BA0-918A-2671BC67117C

Device           Start        End    Sectors  Size Type
/dev/nvme0n1p1    2048    1026047    1024000  500M EFI System
/dev/nvme0n1p2 1026048 3907029134 3906003087  1.8T Linux filesystem
</code></pre>
<h2 id="host-mounts"><a class="header" href="#host-mounts">Host mounts</a></h2>
<p>Container engines allow to bind mount any directory from the host. When using
local, non-clusterized container engines (docker, podman etc.) there are no
restrictions about what can be mounted. In case of Docker, anyone who has an
access to the socket (usually a member of <code>docker</code> group) can mount anything.</p>
<p>That gives every member of the <code>docker</code> group an access to the host OS as root:</p>
<pre><code class="language-bash">❯ docker run --rm --privileged -it -v /:/rootfs opensuse/tumbleweed:latest bash
efa4f6e0529a:/ # chroot /rootfs
sh-4.4#
</code></pre>
<p>The <code>chroot</code> works without <code>--privileged</code> as well:</p>
<pre><code class="language-bash">❯ docker run --rm -it -v /:/rootfs opensuse/tumbleweed:latest bash
abb67212044d:/ # chroot /rootfs
sh-4.4#
</code></pre>
<p>The other approach is to mount a Docker socket. The image used here is <code>docker</code>
which is the official image with Docker binaries installed. After starting the
first container, we are able to list containers running on the host. Then, we
are able to run another container - from inside the first one - which is
mounting directories from the host</p>
<pre><code class="language-bash">❯ docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock docker sh
/ # docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
066811b60d69   docker    &quot;docker-entrypoint.s…&quot;   5 seconds ago   Up 5 seconds             suspicious_liskov
/ # docker run --rm --privileged -it opensuse/tumbleweed:latest bash
fcb94c1d3af6:/ # exit
/ # docker run --rm --privileged -it -v /:/rootfs opensuse/tumbleweed:latest bash
54b08e30fd9e:/ # chroot /rootfs
sh-4.4# cat /etc/os-release
NAME=&quot;openSUSE Leap&quot;
VERSION=&quot;15.3&quot;
ID=&quot;opensuse-leap&quot;
ID_LIKE=&quot;suse opensuse&quot;
VERSION_ID=&quot;15.3&quot;
PRETTY_NAME=&quot;openSUSE Leap 15.3&quot;
ANSI_COLOR=&quot;0;32&quot;
CPE_NAME=&quot;cpe:/o:opensuse:leap:15.3&quot;
BUG_REPORT_URL=&quot;https://bugs.opensuse.org&quot;
HOME_URL=&quot;https://www.opensuse.org/&quot;
</code></pre>
<p>Notice the difference between Linux distibution versions. The second container
image we used is <em>openSUSE Tumbleweed</em>, but the host is running
<em>openSUSE Leap 15.3</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The project consists of 3 parts:</p>
<ul>
<li>the set of BPF programs (written in C)
<ul>
<li>programs for monitoring processes, which detects whether new processes
are running inside any container, which means applying policies on them</li>
<li>programs attached to particular LSM hooks, which allow or deny actions
based on the policy applied to the container (currently all containers have
the <code>baseline</code> policy applied, the mechanism of differentiating between
policies per container/pod is yet to be implemented)</li>
</ul>
</li>
<li><strong>lockcd</strong> - the userspace program (written in Rust)
<ul>
<li>loads the BPF programs into the kernel, pins them in BPFFS</li>
<li>monitors runc processes, registers new containers and determines which
policy should be applied to a container</li>
<li>in future, it's going to serve as the configuration manager and log
collector</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<ul>
<li><a href="build/README.html">Build</a> - How to build lockc from the sources</li>
<li><a href="install/README.html">Install</a> - Configuring and installing lockc</li>
<li><a href="terraform/README.html">Development environment (Terraform)</a> - Using Terraform for setting up development environment lockc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install"><a class="header" href="#install">Install</a></h1>
<p>lockc provides integration with two container engines and separate installation
methods for each of them:</p>
<ul>
<li><strong><a href="install/kubernetes.html">Kubernetes</a></strong> (+ containerd-cri) - installation through a Helm chart,
after which lockc secures newly created pods</li>
<li><strong><a href="install/docker.html">Docker</a></strong> - installation on a single machine with Docker as a loca
container engine</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-docker"><a class="header" href="#with-docker">With Docker</a></h1>
<p>This documentation section explains how to install lockc on a single machine
with Docker. In order to do that, we need to install <code>lockcd</code> binary and a
systemd unit for it.</p>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation methods</a></h2>
<p>There are two ways to do that.</p>
<h3 id="install-with-cargo"><a class="header" href="#install-with-cargo">Install with cargo</a></h3>
<p>If you want to install lockc on a machine where you have the source code of
lockc, you can do it with cargo. You need to build lockc with Cargo before
that. After building lockc, you can install it with the following command.</p>
<pre><code class="language-bash">cargo xtask install
</code></pre>
<p>Do not run this command with sudo! Why?</p>
<p>tl;dr: you will be asked for password when necessary, don't worry!</p>
<p>Explanation: Running cargo with sudo ends with weird consequences like not
seing cargo content from your home directory or leaving some files owned by
root in <code>target</code>. When any destination directory is owned by root, sudo will
be launched automatically by <code>xtask install</code> just to perform necessary
installation steps.</p>
<p>By default it tries to install lockcd binary in <code>/usr/local/bin</code>, but the
destination directory can be changed by the following arguments:</p>
<ul>
<li><code>--destdir</code> - the rootfs of your system, default: <code>/</code></li>
<li><code>--prefix</code> - prefix of the most of installation destinations, default:
<code>usr/local</code></li>
<li><code>--bindir</code> - directory for binary files, default: <code>bin</code></li>
<li><code>--unitdir</code> - directory for systemd units, default: <code>lib/systemd/system</code></li>
<li><code>--sysconfdir</code> - directory for configuration files, default: <code>etc</code></li>
</ul>
<p>By default, binaries are installed from the <code>debug</code> target profile. If you want
to change it, use the <code>--profile</code> argument. <code>--profile release</code> is what you
most likely want to use when packaging or installing on the production system.</p>
<h3 id="unpack-the-bintar"><a class="header" href="#unpack-the-bintar">Unpack the bintar</a></h3>
<p>Documentation sections about:</p>
<ul>
<li><a href="install/../build/dapper.html">building with Dapper</a></li>
<li><a href="install/../build/cargo.html">building with Cargo</a></li>
</ul>
<p>mention <em>Building tarball with binary and unit</em>. To quickly sum it up, you can
build a &quot;bintar&quot; by doing:</p>
<pre><code class="language-bash">dapper cargo xtask bintar
</code></pre>
<p>or:</p>
<pre><code class="language-bash">cargo xtask bintar
</code></pre>
<p>Both commands will produce a bintar available as <code>target/[profile]/lockc.tar.gz</code>
(i.e. <code>target/debug/lockc.tar.gz</code>).</p>
<p>That tarball can be copied to any machine and unpacked with the following
command:</p>
<pre><code class="language-bash">sudo tar -C / -xzf lockc.tar.gz
</code></pre>
<h2 id="verify-the-installation"><a class="header" href="#verify-the-installation">Verify the installation</a></h2>
<p>After installing lockc, you should be able to enable and start the lockcd
service:</p>
<pre><code class="language-bash">sudo systemctl enable --now lockcd
</code></pre>
<p>After starting the service, you can verify that lockc is running by trying to
run a &quot;not containing&quot; container, like:</p>
<pre><code class="language-bash">$ docker run --rm -it -v /:/rootfs registry.opensuse.org/opensuse/toolbox:latest
docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: rootfs_linux.go:76: mounting &quot;/&quot; to rootfs at &quot;/rootfs&quot; caused: mount through procfd: operation not permitted: unknown.
ERRO[0020] error waiting for container: context canceled
</code></pre>
<p>Or you can try to run a less insecure container and try to <code>ls</code> the contents
of <code>/sys</code>:</p>
<pre><code class="language-bash">$ docker run --rm -it registry.opensuse.org/opensuse/toolbox:latest
9b34d760017f:/ # ls /sys
ls: cannot open directory '/sys': Operation not permitted
9b34d760017f:/ # ls /sys/fs/btrfs
ls: cannot access '/sys/fs/btrfs': No such file or directory
9b34d760017f:/ # ls /sys/fs/cgroup
blkio  cpu,cpuacct  cpuset   freezer  memory  net_cls           net_prio    pids  systemd
cpu    cpuacct      devices  hugetlb  misc    net_cls,net_prio  perf_event  rdma
</code></pre>
<p>You should be able to see cgroups (which is fine), but other parts of <em>/sys</em>
should be hidden.</p>
<p>However, running insecure containers as root with <code>privileged</code> policy level
should work:</p>
<pre><code class="language-bash">$ sudo -i
# docker run --label org.lockc.policy=privileged --rm -it -v /:/rootfs registry.opensuse.org/opensuse/toolbox:latest bash
8ea310609fce:/ # 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on-kubernetes"><a class="header" href="#on-kubernetes">On Kubernetes</a></h1>
<p>This section explains how to install lockc on a Kubernetes cluster with
<a href="https://helm.sh/">helm</a>.</p>
<p>The helm chart is available on <a href="https://lockc-project.github.io/helm-charts/">lockc-helm-chart</a>
website. Installation with default values can be done with:</p>
<pre><code class="language-bash">kubectl apply -f https://lockc-project.github.io/helm-charts/namespace.yaml
helm repo add lockc https://lockc-project.github.io/helm-charts/
helm install -n lockc lockc lockc/lockc
</code></pre>
<p>More info on lockc helm chart installation can be found <a href="https://lockc-project.github.io/helm-charts/">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policies"><a class="header" href="#policies">Policies</a></h1>
<p>lockc provides three policy levels for containers:</p>
<ul>
<li><strong>baseline</strong> - meant for regular applications</li>
<li><strong>restricted</strong> - meant for applications for which we need to be more cautious
and secure them more stricly</li>
<li><strong>privileged</strong> - meant for part of the infrastructure which can have full
access to host resources - i.e. CNI plugins in Kubernetes</li>
</ul>
<p>The default policy level is <strong>baseline</strong>. The policy level can be changed by
the <code>pod-security.kubernetes.io/enforce</code> label on the <strong>namespace</strong> which
the container is running in. We make an exception for the <em>kube-system</em>
namespace for which the <strong>privileged</strong> policy is applied by default.</p>
<p>For now there is no possibility to apply policy levels on local container
engines (Docker, containerd, podman), but such feature is planned in the
future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-access"><a class="header" href="#file-access">File access</a></h1>
<p>lockc comes with policies about file access which is based on allow- and
deny-listing. <strong>Baseline</strong> and <strong>restricted</strong> policies have their own pairs of
lists. All those lists should contain path prefixes. All the children of listed
paths/directories are included, since the decision is made by prefix matching.</p>
<p>The deny list has precedence over allow list. That's because main purpose of
the deny list is specifying exceptions whose prefixes are specified in the
allow list, but we don't want to allow them.</p>
<p>To sum it up, when any process in the container tries to access a file, lockc:</p>
<ol>
<li>Checks whether the given path's prefix is in the deny list. If yes, denies
the access.</li>
<li>Checks whether the given path's prefix is in the allow list. If yes, allows
the access.</li>
<li>In case of no matches, denies the access.</li>
</ol>
<p>By default, the contents of lists are:</p>
<ul>
<li><strong>baseline</strong>
<ul>
<li>allow list
<ul>
<li><em>/bin</em></li>
<li><em>/dev/console</em></li>
<li><em>/dev/full</em></li>
<li><em>/dev/null</em></li>
<li><em>/dev/pts</em></li>
<li><em>/dev/tty</em></li>
<li><em>/dev/urandom</em></li>
<li><em>/dev/zero</em></li>
<li><em>/etc</em></li>
<li><em>/home</em></li>
<li><em>/lib</em></li>
<li><em>/proc</em></li>
<li><em>/sys/fs/cgroup</em></li>
<li><em>/tmp</em></li>
<li><em>/usr</em></li>
<li><em>/var</em></li>
</ul>
</li>
<li>deny list
<ul>
<li><em>/proc/acpi</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>restricted</strong>
<ul>
<li>allow list
<ul>
<li><em>/bin</em></li>
<li><em>/dev/console</em></li>
<li><em>/dev/full</em></li>
<li><em>/dev/null</em></li>
<li><em>/dev/pts</em></li>
<li><em>/dev/tty</em></li>
<li><em>/dev/urandom</em></li>
<li><em>/dev/zero</em></li>
<li><em>/etc</em></li>
<li><em>/home</em></li>
<li><em>/lib</em></li>
<li><em>/proc</em></li>
<li><em>/sys/fs/cgroup</em></li>
<li><em>/tmp</em></li>
<li><em>/usr</em></li>
<li><em>/var</em></li>
</ul>
</li>
<li>deny list
<ul>
<li><em>/proc/acpi</em></li>
<li><em>/proc/sys</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>By default, with the <strong>baseline</strong> policy level, this is a good exampole of not
allowed behavior:</p>
<pre><code class="language-bash"># docker run --rm -it registry.opensuse.org/opensuse/toolbox:latest
9b34d760017f:/ # ls /sys
ls: cannot open directory '/sys': Operation not permitted
9b34d760017f:/ # ls /sys/fs/btrfs
ls: cannot access '/sys/fs/btrfs': No such file or directory
9b34d760017f:/ # ls /sys/fs/cgroup
blkio  cpu,cpuacct  cpuset   freezer  memory  net_cls           net_prio    pids  systemd
cpu    cpuacct      devices  hugetlb  misc    net_cls,net_prio  perf_event  rdma
</code></pre>
<p>We are able to see cgroups (which is fine), but other parts of <em>/sys</em> are
hidden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mount-policies"><a class="header" href="#mount-policies">Mount policies</a></h1>
<p>lockc comes with the following policies about bind mounts from host filesystem
to containers (via <code>-v</code> option) for each policy level:</p>
<ul>
<li><strong>baseline</strong> - allow bind mounting from inside <code>/home</code> and <code>/var/data</code>.</li>
<li><strong>restricted</strong> - does not allow any bind mounts from host</li>
<li><strong>privileged</strong> - no restrictions, everything can be bind mounted</li>
</ul>
<p>The <strong>baseline</strong> behavior in lockc is slightly different than in the Kubernetes
Pod Security Admission controller, which disallows all host mounts for baseline
containers as well as for restricted. The motivation behind allowing <code>/home</code>
and <code>/var/data</code> by lockc is that they are often used in local container engines
(Docker, podman) for reasons like:</p>
<ul>
<li>mounting the source code to build or check</li>
<li>storing database content on the host for local development</li>
</ul>
<p>By default, with the <strong>baseline</strong> policy level, this is a good example of
not allowed behavior:</p>
<pre><code class="language-bash"># docker run --rm -it -v /:/rootfs registry.opensuse.org/opensuse/toolbox:latest
docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: rootfs_linux.go:76: mounting &quot;/&quot; to rootfs at &quot;/rootfs&quot; caused: mount through procfd: operation not permitted: unknown.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syslog"><a class="header" href="#syslog">Syslog</a></h1>
<p>lockc comes with the following policies about access to the kernel message ring
buffer for each policy level:</p>
<ul>
<li><strong>baseline</strong> - not allowed</li>
<li><strong>restricted</strong> - not allowed</li>
<li><strong>privileged</strong> - allowed</li>
</ul>
<p>By default, with the <strong>baseline</strong> policy level, checking the kernel logs from
the container is not allowed:</p>
<pre><code class="language-bash"># docker run -it --rm registry.opensuse.org/opensuse/toolbox:latest
b10f9fa4a385:/ # dmesg
dmesg: read kernel buffer failed: Operation not permitted
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuning"><a class="header" href="#tuning">Tuning</a></h1>
<p>This guide shows options and tricks to gain an optimal performance and resouce
usage.</p>
<h2 id="memory-usage"><a class="header" href="#memory-usage">Memory usage</a></h2>
<p>Memory usage by lockc depends mostly on BPF maps size. BPF maps are stored in
memory and the biggest BPF maps are the ones related to tracking processes and
containers. Size of those maps depends on the limit of processes (in separate
memory spaces) in the system. That limit is determined by the <code>kernel.pid_max</code>
sysctl. By default the limit is 32768. With such limit, memory usage by lockc
should be aproximately 10-20 MB.</p>
<p>If you observe too much memory being used after installing lockc, try to check
the value of <code>kernel.pid_max</code>, which can be done with:</p>
<pre><code class="language-bash">sudo sysctl kernel.pid_max
</code></pre>
<p>Change of that value (i.e. to 10000) can be done with:</p>
<pre><code class="language-bash">sudo sysctl kernel.pid_max=10000
</code></pre>
<p>But that change will be not persistent after reboot. Changing it persistently
requires adding a configuration to <code>/etc/sysctl.d</code>. I.e. we could create the
file <code>/etc/sysctl.d/05-lockc.conf</code> with the following content:</p>
<pre><code class="language-bash">kernel.pid_max = 10000
</code></pre>
<p>After creating that file, the lower limit is going to be persistent after
reboot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h1>
<ul>
<li><a href="developers/repositories.html">Repositories</a> - Cloning and working with our git repositories</li>
<li><a href="developers/build/README.html">Build</a> - How to build lockc from the sources</li>
<li><a href="developers/terraform/README.html">Development environment (Terraform)</a> - Using Terraform for setting up development environment lockc</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repositories"><a class="header" href="#repositories">Repositories</a></h1>
<p>lockc currently uses two git repositories:</p>
<ul>
<li><strong><a href="https://github.com/lockc-project/lockc">lockc-project/lockc</a></strong> - the
main repository containing lockc source code</li>
<li><strong><a href="https://github.com/lockc-project/helm-charts">lockc-project/helm-charts</a></strong> -
repository with Helm charts to deploy lockc on Kubernetes</li>
</ul>
<p>If you are interested in development and contributing to lockc, we recommend to
fork and clone both of them. Both will be needed especially for building a
<a href="developers/terraform/README.html">development environment based on Terraform</a>.</p>
<p>The latter chapters assume that you have <strong>lockc</strong> and <strong>helm-charts</strong>
cloned in the same parent directory. For example, as
<em>$HOME/my-repositories/lockc</em> and <em>$HOME/my-repositories/helm-charts</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-lockc"><a class="header" href="#building-lockc">Building lockc</a></h1>
<p>The first step to try out lockc is to build it. There are several ways to do
that:</p>
<ul>
<li><strong><a href="developers/build/cargo.html">Cargo</a></strong> - build binaries with Cargo (Rust build system) on the host
<ul>
<li>convenient for local development, IDE/editor integration</li>
</ul>
</li>
<li><strong><a href="developers/build/container-image.html">Container image</a></strong> - build a container image which can be deployed on
Kubernetes
<ul>
<li>the only method to try lockc on Kubernetes</li>
<li>doesn't work for Docker integration, where we rather install lockc as a
binary on the host, managed by systemd</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>lockc is written entirely in Rust and uses Cargo as a build system.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>This document assumes that you have Rust installed with
<a href="https://rustup.rs/">rustup</a>.</p>
<p>To build lockc, you will need Rust stable and nightly:</p>
<pre><code class="language-bash">rustup install stable
rustup toolchain install nightly --component rust-src
</code></pre>
<p>Then you need to install <code>bpf-linker</code> for linking eBPF programs:</p>
<pre><code class="language-bash">cargo install bpf-linker
</code></pre>
<p>By default, <code>bpf-linker</code> is trying to use the internal LLVM library available
in Rust. That might not work if you are using musl target. In such case, you
need to install LLVM with static libraries on your host system and then install
<code>bpf-linker</code> with a different command:</p>
<pre><code class="language-bash">cargo install --git https://github.com/aya-rs/bpf-linker --tag v0.9.3 --no-default-features --features system-llvm -- bpf-linker
</code></pre>
<h2 id="building-lockc-1"><a class="header" href="#building-lockc-1">Building lockc</a></h2>
<p>After installing all needed dependencies, it's time to build lockc.</p>
<p>You can build and run the entire project with:</p>
<pre><code class="language-bash">cargo xtask run
</code></pre>
<p>If you prefer to only build the project, it be done with:</p>
<pre><code class="language-bash">cargo xtask build-ebpf
cargo build
</code></pre>
<p>Running tests:</p>
<pre><code class="language-bash">cargo test
</code></pre>
<p>Running lints:</p>
<pre><code class="language-bash">cargo clippy
</code></pre>
<h2 id="installing-lockc"><a class="header" href="#installing-lockc">Installing lockc</a></h2>
<p>To install lockc on your host, use the following command:</p>
<pre><code class="language-bash">cargo xtask install
</code></pre>
<p>Do not run this command with sudo! Why?</p>
<p>tl;dr: you will be asked for password when necessary, don't worry!</p>
<p>Explanation: Running cargo with sudo ends with weird consequences like not
seing cargo content from your home directory or leaving some files owned by
root in <code>target</code>. When any destination directory is owned by root, sudo will
be launched automatically by <code>xtask install</code> just to perform necessary
installation steps.</p>
<p>By default it tries to install lockcd binary in <code>/usr/local/bin</code>, but the
destination directory can be changed by the following arguments:</p>
<ul>
<li><code>--destdir</code> - the rootfs of your system, default: <code>/</code></li>
<li><code>--prefix</code> - prefix of the most of installation destinations, default:
<code>usr/local</code></li>
<li><code>--bindir</code> - directory for binary files, default: <code>bin</code></li>
<li><code>--unitdir</code> - directory for systemd units, default: <code>lib/systemd/system</code></li>
<li><code>--sysconfdir</code> - directory for configuration files, default: <code>etc</code></li>
</ul>
<p>By default, binaries are installed from the <code>debug</code> target profile. If you want
to change it, use the <code>--profile</code> argument. <code>--profile release</code> is what you
most likely want to use when packaging or installing on the production system.</p>
<h2 id="building-tarball-with-binary-and-unit"><a class="header" href="#building-tarball-with-binary-and-unit">Building tarball with binary and unit</a></h2>
<p>To make distribution of lockc for Docker users easier, we have a possibility of
building an archive with binary and systemd unit which can be just unpacked in
<code>/</code> directory. It can be done by the following command:</p>
<pre><code class="language-bash">cargo xtask bintar
</code></pre>
<p>By default it archives lockcd binary in <code>usr/local/bin</code>, but the
destination directory can be changed by the following arguments:</p>
<ul>
<li><code>--prefix</code> - prefix of the most of installation destinations, default:
<code>usr/local</code></li>
<li><code>--bindir</code> - directory for binary files, default: <code>bin</code></li>
<li><code>--unitdir</code> - directory for systemd units, default: <code>lib/systemd/system</code></li>
<li><code>--sysconfdir</code> - directory for configuration files, default: <code>etc</code></li>
</ul>
<p>By default, binaries are installed from the <code>debug</code> target profile. If you want
to change it, use the <code>--profile</code> argument. <code>--profile release</code> is what you
most likely want to use when creating a tarball for releases and production
systems.</p>
<p>The resulting binary should be available as <code>target/[profile]/lockc.tar.gz</code>
(i.e. <code>target/debug/lockc.tar.gz</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-image"><a class="header" href="#container-image">Container image</a></h1>
<p>lockc repository contains a <code>Dockerfile</code> which can be used for building a
container image. The main purpose of building it is ability to deploy lockc on
Kubernetes.</p>
<p>Building a local image can be done in a basic way, like:</p>
<pre><code class="language-bash">docker build -t lockcd .
</code></pre>
<p>For quick development and usage of the image on different (virtual) machines,
it's convenient to use <a href="https://ttl.sh/">ttl.sh</a> which is an anonymous and
ephemeral container image registry.</p>
<p>To build and push an image to ttl.sh, you can use the following commands:</p>
<pre><code class="language-bash">export IMAGE_NAME=$(uuidgen)
docker build -t ttl.sh/${IMAGE_NAME}:30m .
docker push ttl.sh/${IMAGE_NAME}:30m
</code></pre>
<p>After building the container image, you will be able to
<a href="developers/build/../install/kubernetes.html">install lockc on Kubernetes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment-vagrant"><a class="header" href="#development-environment-vagrant">Development environment (Vagrant)</a></h1>
<p>There is a possibility to run lockc build from source in a virtual machine using
Vagrant:</p>
<pre><code class="language-bash">vagrant up
</code></pre>
<p>Our <code>Vagrantfile</code> supports the following environment variables:</p>
<ul>
<li><code>LOCKC_VAGRANT_CPUS</code> - number of vCPUs</li>
<li><code>LOCKC_VAGRANT_MEMOORY</code> - memory (in MB)</li>
</ul>
<p>When VM is provisioned successfully, you can access it using:</p>
<pre><code class="language-bash">vagrant ssh
</code></pre>
<p>That VM contains is running <a href="https://k3s.io/">k3s</a>. It's also running lockc as
a systemd service, which can be checked with:</p>
<pre><code class="language-bash">sudo systemctl status lockc
sudo journalctl -fu lockc
</code></pre>
<p>lockc source tree is available in <code>/vagrant</code> directory. After making changes in
code, you can sync the changes (from the host):</p>
<pre><code class="language-bash">vagrant rsync
</code></pre>
<p>Then build, install and restart lockc in VM (inside <code>vagrant ssh</code> session):</p>
<pre><code class="language-bash">sudo systemctl stop lockc
cargo xtask build-ebpf
cargo build
cargo xtask install
sudo systemctl start lockc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demos"><a class="header" href="#demos">Demos</a></h1>
<p>This section of the book contains demos.</p>
<ul>
<li><a href="demos/mount.html">Mount</a> - mount policies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mount-policies-1"><a class="header" href="#mount-policies-1">Mount policies</a></h1>
<h2 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h2>
<p>The following demo shows mount policies being enforced on Kubernetes pods.</p>
<p>YAML files can be found <a href="https://github.com/lockc-project/lockc/tree/main/examples/kubernetes">here</a>.</p>
<p>The policy violations in <a href="https://github.com/lockc-project/lockc/tree/main/examples/kubernetes/deployments-should-fail.yaml">deployments-should-fail.yaml</a>
file are:</p>
<ul>
<li><em>nginx-restricted-fail</em> deployment trying to make a host mount while having a
<strong>restricted</strong> policy</li>
<li><em>bpf-default-fail</em> and <em>bpf-baseline-fail</em> deployment trying to mount
<code>/sys/fs/bpf</code> while having a <strong>baseline</strong> policy</li>
<li><em>bpf-restricted-fail</em> trying to mount <code>/sys/fs/bpf</code> while having a
<strong>restricted</strong> policy.</li>
</ul>
<p><a href="https://asciinema.org/a/sUxMMB5BKkJzlF1jP6k8Bxab3"><img src="https://asciinema.org/a/sUxMMB5BKkJzlF1jP6k8Bxab3.svg" alt="asciicast" /></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
